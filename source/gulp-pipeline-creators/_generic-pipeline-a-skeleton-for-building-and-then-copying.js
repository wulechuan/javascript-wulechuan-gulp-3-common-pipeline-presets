module.exports = buildAPipelineForBuildingOneAppOrOnePage;

/*
*
*
*
*
*
*
* ****************************************
*           任务集工厂函数；工具
* ****************************************
*/

const pathTool = require('path');
const deleteFiles = require('del');

const gulp = require('gulp');
const runTasksSequentially = require('gulp-sequence');

// const chalk = require('chalk');

const { join: joinPath } = pathTool;
const { sync: deleteFilesSync } = deleteFiles;

const getValidatedGlobsFrom = require('../utils/get-validated-globs');
// const printInfoAboutTheCompletionOfTask = require('../utils/print-one-task-done');
const createTaskForCopyingFiles         = require('../gulp-task-creators/_generic-copy-files');

const { namePrefixOfEveryAutoGeneratedTask } = require('../configurations');


function buildAPipelineForBuildingOneAppOrOnePage({ // eslint-disable-line max-statements
	// logging
	pipelineCategory,                           // e.g. 'Javascript' or '爪哇脚本'
	taskNameKeyPart,                            // e.g. 'Page: User Dashboard' or maybe just 'App'
	basePathForShorteningPathsInLog = '',       // e.g. 'front-end/source/js' or 'front-end/source', anything you like.

	// source
	sourceBasePath,                             // e.g. 'front-end/source/js'
	buildingEntryGlobsRelativeToSourceBasePath, // e.g. [ '**/*.js' ]
	watchingBasePath,
	watchingGlobsRelativeToWatchingBasePath,    // e.g. [ '**/*.js' ]

	// building
	outputBasePathOfBuilding,                   // e.g. '../static' or 'dist/assets'
	builtGlobsRelativeToOutputBasePathOfBuilding = [],

	// A function to create another function,
	// the created function will be used
	// as the task body of building process upon source globs.
	toCreateBuildingTaskBody,

	// copying
	shouldCopyBuiltFileToElsewhere = false,
	outputBasePathOfCopying, // e.g. 'build/tryout-website/assets'
	optionsOfCopyingFiles,   // will be passed to **createTaskForCopyingFiles**
}) {
	const resolvedPathsOfEntryGlobsForBuilding = getValidatedGlobsFrom({
		rawGlobs: buildingEntryGlobsRelativeToSourceBasePath,
		defaultValue: [ '**/*' ],
	}).map(
		glob => joinPath(sourceBasePath, glob)
	);


	const validatedBuiltRelativeGlobs = getValidatedGlobsFrom({
		rawGlobs: builtGlobsRelativeToOutputBasePathOfBuilding,
		defaultValue: [ '**/*' ],
	});

	const resolvedPathsOfBuiltGlobs = validatedBuiltRelativeGlobs.map(
		glob => joinPath(outputBasePathOfBuilding, glob)
	);



	let resolvedPathsOfGlobsToDeleteBeforeEachBuild = [
		...resolvedPathsOfBuiltGlobs,
	];





	let resolvedPathsOfGlobsToCopyAfterEachBuild;
	let resolvedPathsOfCopiesOfBuiltGlobs;

	if (shouldCopyBuiltFileToElsewhere) {
		resolvedPathsOfGlobsToCopyAfterEachBuild = [
			...resolvedPathsOfBuiltGlobs,
		];

		resolvedPathsOfCopiesOfBuiltGlobs = [
			...validatedBuiltRelativeGlobs.map(
				glob => joinPath(outputBasePathOfCopying, glob)
			),
		];

		resolvedPathsOfGlobsToDeleteBeforeEachBuild = [
			...resolvedPathsOfGlobsToDeleteBeforeEachBuild,
			...resolvedPathsOfCopiesOfBuiltGlobs,
		];
	}







	const pipelineFullName = `${pipelineCategory}: ${taskNameKeyPart}`;

	const taskNameOfDeletingFiles          = `${namePrefixOfEveryAutoGeneratedTask} Delete old files: ${       pipelineFullName}`;
	const taskNameOfBuilding               = `${namePrefixOfEveryAutoGeneratedTask} Build: ${                  pipelineFullName}`;
	const taskNameOfCopyingFiles           = `${namePrefixOfEveryAutoGeneratedTask} Copy built output files: ${pipelineFullName}`;
	const taskNameOfBuildingAndThenCopying = `${namePrefixOfEveryAutoGeneratedTask} Build and then copy: ${    pipelineFullName}`;

	let taskNameOfLastTaskInThisPipeline;
	if (shouldCopyBuiltFileToElsewhere) {
		taskNameOfLastTaskInThisPipeline = taskNameOfBuildingAndThenCopying;
	} else {
		taskNameOfLastTaskInThisPipeline = taskNameOfBuilding;
	}





	const taskBodyOfDeletingFiles = (thisTaskIsDone) => {
		deleteFilesSync(resolvedPathsOfGlobsToDeleteBeforeEachBuild, {
			force: true, // force 为 true，是为了删除位于 npm 项目文件夹之外的文件。
		});
		// printInfoAboutTheCompletionOfTask(taskNameForDeletingFiles, false);
		thisTaskIsDone();
	};

	const taskBodyOfBuilding = toCreateBuildingTaskBody({
		taskNameKeyPart,
		entryGlobsForBuilding: resolvedPathsOfEntryGlobsForBuilding,
		outputBasePathOfBuilding,
		basePathForShorteningPathsInLog,
	});




	let taskBodyOfCopyingFiles;
	let taskBodyOfBuildingAndThenCopyingBuiltOutputFiles;
	let actionToTakeOnSourceFilesChange;

	if (shouldCopyBuiltFileToElsewhere) {
		const usedOptionsOfCopyingFiles = {
			...{
				shouldFlattenSubFolders: false,
				logPrefix: taskNameOfCopyingFiles,
				shouldNotLogDetails: true,
				shouldListSourceFiles: false,
			},

			...optionsOfCopyingFiles,
		};

		taskBodyOfCopyingFiles = createTaskForCopyingFiles(
			resolvedPathsOfGlobsToCopyAfterEachBuild,
			outputBasePathOfCopying,
			usedOptionsOfCopyingFiles
		);




		taskBodyOfBuildingAndThenCopyingBuiltOutputFiles = (thisTaskIsDone) => {
			runTasksSequentially(
				taskNameOfBuilding,
				taskNameOfCopyingFiles
			)(thisTaskIsDone);
		};


		actionToTakeOnSourceFilesChange = taskBodyOfBuildingAndThenCopyingBuiltOutputFiles;
	} else {
		actionToTakeOnSourceFilesChange = taskBodyOfBuilding;
	}







	gulp.task(taskNameOfDeletingFiles, taskBodyOfDeletingFiles);
	gulp.task(taskNameOfBuilding, [ taskNameOfDeletingFiles ], taskBodyOfBuilding);
	if (shouldCopyBuiltFileToElsewhere) {
		gulp.task(taskNameOfCopyingFiles, taskBodyOfCopyingFiles);
		gulp.task(taskNameOfBuildingAndThenCopying, taskBodyOfBuildingAndThenCopyingBuiltOutputFiles);
	} else {
		gulp.task(taskNameOfBuilding, taskBodyOfBuilding);
	}





	const pipelineSettings = {
		// logging
		pipelineFullName,

		// globs of pipeline
		resolvedPathsOfEntryGlobsForBuilding,
		resolvedPathsOfBuiltGlobs,
		resolvedPathsOfGlobsToDeleteBeforeEachBuild,

		// globs for watching
		watchingBasePath,
		watchingGlobsRelativeToWatchingBasePath,

		// task names

		taskNameOfLastTaskInThisPipeline,
		taskNameOfBuilding,               // 或可用于一次性编译或构建任务
		taskNameOfDeletingFiles,          // 或可用于完整清除所有构建输出的任务

		// task bodies
		toBuild: taskBodyOfBuilding,      // 或可用于一次性编译或构建任务
		toClean: taskBodyOfDeletingFiles, // 我想其实基本用不到

		actionToTakeOnSourceFilesChange,  // 显然，这是针对【文件变动监测机制】的
	};


	if (shouldCopyBuiltFileToElsewhere) {
		pipelineSettings.resolvedPathsOfGlobsToCopyAfterEachBuild = resolvedPathsOfGlobsToCopyAfterEachBuild;
		pipelineSettings.resolvedPathsOfCopiesOfBuiltGlobs        = resolvedPathsOfCopiesOfBuiltGlobs;

		pipelineSettings.taskNameOfCopyingFiles                   = taskNameOfCopyingFiles;
		pipelineSettings.taskNameOfBuildingAndThenCopying         = taskNameOfBuildingAndThenCopying;

		pipelineSettings.toCopyBuildingOutputFiles                = taskBodyOfCopyingFiles;
		pipelineSettings.toBuildAndThenCopy                       = taskBodyOfBuildingAndThenCopyingBuiltOutputFiles;
	}





	return pipelineSettings;
}
